========================================================================
    CONSOLE APPLICATION : ExplicitClientADLL Project Overview
========================================================================

AppWizard has created this ExplicitClientADLL application for you.  

This file contains a summary of what you will find in each of the files that
make up your ExplicitClientADLL application.


ExplicitClientADLL.vcproj
    This is the main project file for VC++ projects generated using an Application Wizard. 
    It contains information about the version of Visual C++ that generated the file, and 
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

ExplicitClientADLL.cpp
    This is the main application source file.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named ExplicitClientADLL.pch and a precompiled types file named StdAfx.obj.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" comments to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////
EXPORTS
entryname[=internalname] [@ordinal [NONAME]] [PRIVATE] [DATA]
EXPORTS
func2=func1

///////////
@ordinal lets you specify that a number, and not the function name,
 will go into the DLL's export table. 
 This can help you minimize the size of your DLL. 
 The .LIB file will contain the mapping between the ordinal and 
 the function, which allows you to use the function name 
 as you normally would in projects that use the DLL.

The optional NONAME keyword allows you to export by ordinal only 
and reduce the size of the export table in the resulting DLL. 
However, if you want to use GetProcAddress on the DLL, 
you must know the ordinal because the name will not be valid.

The optional keyword PRIVATE prevents entryname 
from being placed in the import library generated by LINK. 
It has no effect on the export in the image also generated by LINK.

The optional keyword DATA specifies that an export is data, not code. 
For example, you could export a data variable as follows:
EXPORTS
i DATA


When you use PRIVATE and DATA for the same export, 
PRIVATE must precede DATA.

There are three methods for exporting a definition,
listed in recommended order of use: 

	1)The __declspec(dllexport) keyword in the source code
	2)An EXPORTS statement in a .def file
	3)An /EXPORT specification in a LINK command

All three methods can be used in the same program. 
When LINK builds a program that contains exports, 
it also creates an import library,
unless an .exp file is used in the build.

The following is an example EXPORTS section:
EXPORTS
   DllCanUnloadNow      @1     PRIVATE   DATA
   DllWindowName = Name        DATA
   DllGetClassObject    @4 NONAME   PRIVATE
   DllRegisterServer    @7
   DllUnregisterServer
   
Note that when you export a variable from a DLL with a .def file, 
you do not need to specify __declspec(dllexport) on the variable. 
However, in any file that uses the DLL, 
you must still use __declspec(dllimport) on the declaration of data.

////////
/HEAP:reserve[,commit]
//////
LIBRARY [library][BASE=address]
The library argument specifies the name of the DLL. 
You can also use the /OUT linker option to specify the DLL's output name.
The BASE=address argument sets the base address 
that the operating system uses to load the DLL. 
This argument overrides the default DLL location of 0x10000000. 
See the description of the /BASE option for details about base addresses. 

Remember to use the /DLL linker option when you build a DLL.
////////
/BASE:{address[,size] | @filename,key}
The /BASE option sets a base address for the program, 
overriding the default location for an .exe file (at 0x400000) or 
a DLL (at 0x10000000). 
The operating system first attempts 
to load a program at its specified or default base address. 
If sufficient space is not available there, 
the system relocates the program. 
To prevent relocation, use the /FIXED option. 

The linker issues an error if address is not a multiple of 64K. 
You can optionally specify the size of the program, 
so the linker will warn if the program can not fit in the size 
you specified.

On the command line, another way to specify the base address is 
by using the filename preceded by an at sign (@), and a key into the file.
 The filename is a text file that contains the locations and 
 sizes of all the DLLs your program will use. 
 The linker looks for filename in either the specified path or, 
 if no path is specified, 
 in directories specified in the LIB environment variable. 
 Each line in filename represents one DLL and has the following syntax:
 
 key address [size] ;comment
 The key is a string of alphanumeric characters and is not case sensitive. 
 It is usually the name of a DLL, but it need not be. 
 The key is followed by a base address in C-language, hexadecimal, 
 or decimal notation and an optional maximum size. 
 All three arguments are separated by spaces or tabs. 
 The linker issues a warning if the specified size is less than 
 the virtual address space required by the program. 
 A comment is specified by a semicolon (;) and can be on the same or 
 a separate line. The linker ignores all text from 
 the semicolon to the end of the line. 
 This example shows part of such a file:
 
 main   0x00010000    0x08000000    ; for PROJECT.exe
 one    0x28000000    0x00100000    ; for DLLONE.DLL
 two    0x28100000    0x00300000    ; for DLLTWO.DLL
 
 If the file that contains these lines is called DLLS.txt, 
 the following example command applies this information:

  Copy Code 
 link dlltwo.obj /dll /base:@dlls.txt,two
 //////////////////////////////////////////////////////
 
 /FIXED[:NO]
Remarks
The /FIXED option tells the operating system 
to load the program only at its preferred base address. 
If the preferred base address is unavailable, 
the operating system will not load the file. 
For more information, see /BASE (Base Address). 

By default, /FIXED:NO is the default when building a DLL, 
and /FIXED is the default for any other project type.

When /FIXED is specified, 
LINK does not generate a relocation section in the program. 
At run time, if the operating system is unable 
to load the program at that address, 
it issues an error message and does not load the program.

Specify /FIXED:NO to generate a relocation section in the program.

Do not use /FIXED when building device drivers for Windows NT.

To set this linker option in the Visual Studio development environment
Open the project's Property Pages dialog box. 
For details, see Setting Visual C++ Project Properties. 

Click the Linker folder.
Click the Command Line property page.
Type the option into the Additional Options box.
 
 //////
 Specifies a name for the main output file.

  Copy Code 
NAME [application][BASE=address]
 

Remarks
An equivalent way to specify an output file name is 
with the /OUT linker option, and an equivalent way to set 
the base address is with the /BASE linker option. 
If both are specified, /OUT overrides NAME. 

If you build a DLL, NAME 

///////
Introduces a section of one or more definitions 
that are access specifiers on sections in your project's output file.

  Copy Code 
SECTIONS
definitions
 

Remarks
Each definition must be on a separate line. 
The SECTIONS keyword can be on the same line 
as the first definition or on a preceding line. 
The .def file can contain one or more SECTIONS statements.

This SECTIONS statement sets attributes for one or more sections 
in the image file, and can be used 
to override the default attributes for each type of section.

The format for definitions is:

.section_name specifier

where .section_name is the name of a section in your program image and 
specifier is one or more of the following access modifiers: 

EXECUTE
READ
SHARED
WRITE

Separate specifier names with a space. For example:

  Copy Code 
SECTIONS
.rdata READ WRITE
 

SECTIONS marks the beginning of a list of section definitions. 
Each definition must be on a separate line. 
The SECTIONS keyword can be on the same line as the first definition or 
on a preceding line. 
The .def file can contain one or more SECTIONS statements. 
The SEGMENTS keyword is supported as a synonym for SECTIONS.

Older versions of Visual C++ supported:

  Copy Code 
section [CLASS 'classname'] specifier
 

The CLASS keyword is supported for compatibility, but is ignored.
An equivalent way to specify section attributes is 
with the /SECTION option.
//////
Sets the size of the stack in bytes.

  Copy Code 
STACKSIZE reserve[,commit]
 

Remarks
An equivalent way to set the stack is with the Stack Allocations 
(/STACK) option. See the documentation on that option 
/STACK:reserve[,commit]
 

Remarks
The /STACK option sets the size of the stack in bytes. 
This option is only for use when building an .exe file.

This option specifies the total stack allocation in virtual memory. 
The default stack size is 1 MB. The linker rounds up the specified value 
to the nearest 4 bytes.

commit is subject to interpretation by the operating system. 
In Windows NT and Windows 2000 it specifies the amount of physical memory 
to allocate at a time. Committed virtual memory causes space 
to be reserved in the paging file. 
A higher commit value saves time when the application needs 
more stack space, but increases the memory requirements and 
possibly the startup time.

Specify the reserve and commit values in decimal or C-language notation.

Another way to set the size of the stack is with the STACKSIZE statement 
in a module-definition (.def) file. 
STACKSIZE overrides the Stack Allocations (/STACK) option if both are specified. You can change the stack after the .exe file is built by using the EDITBIN tool. 

To set this linker option in the Visual Studio development environment
Open the project's Property Pages dialog box. For details, see Setting Visual C++ Project Properties. 

Click the Linker folder.
Click the System property page.

Modify one of the following properties: 

Stack Commit Size
Stack Reserve Size

To set this linker option programmatically
////////////////
Tells LINK to put a number in the header of the .exe file or DLL. 

  Copy Code 
VERSION major[.minor] 

Remarks
The major and minor arguments are decimal numbers in 
the range 0 through 65,535. The default is version 0.0.

An equivalent way to specify a version number is with the 
Version Information (/VERSION) option. 

See Also
/////////////////
/SWAPRUN:{NET|CD}
 

Remarks
The /SWAPRUN option tells the operating system 
to first copy the linker output to a swap file, 
and then run the image from there. 
This is a Windows NT 4.0 (and later) feature.

If NET is specified, the operating system will first copy 
the binary image from the network to a swap file and load it from there. 
This option is useful for running applications over the network. 
When CD is specified, 
the operating system will copy the image on a removable disk 
to a page file and then load it.

To set this linker option in the Visual Studio development environment
Open the project's Property Pages dialog box. 
For details, see Setting Visual C++ Project Properties. 

Click the Linker folder.
Click the System property page.

Modify one of the following properties:
Swap Run From CD
Swap Run From Network

To set this linker option programmatically
See SwapRunFromCD and SwapRunFromNet properties.

See Also
//////////////////////////
/ENTRY:function
 

Remarks
where:

function
A function that specifies a user-defined starting address 
for an .exe file or DLL.

Remarks
The /ENTRY option specifies an entry point function 
as the starting address for an .exe file or DLL.

The function must be defined with the __stdcall calling convention. 
The parameters and return value must be defined as documented in 
the Win32 API for WinMain (for an .exe file) or DllEntryPoint (for a DLL).
 It is recommended that you let the linker set the entry point so 
 that the C run-time library is initialized correctly, 
 and C++ constructors for static objects are executed.

By default, the starting address is a function name 
from the C run-time library. 
The linker selects it according to the attributes of the program, 
as shown in the following table.

Function name  Default for  
mainCRTStartup (or wmainCRTStartup)
 An application using /SUBSYSTEM:CONSOLE; calls main (or wmain)
 
WinMainCRTStartup (or wWinMainCRTStartup)
 An application using /SUBSYSTEM:WINDOWS; calls WinMain (or wWinMain), 
 which must be defined with __stdcall
 
_DllMainCRTStartup
 A DLL; calls DllMain, which must be defined with __stdcall, 
 if it exists
 

If the /DLL or /SUBSYSTEM option is not specified, 
the linker selects a subsystem and entry point depending on 
whether main or WinMain is defined. 

The functions main, WinMain, and DllMain are the three forms of 
the user-defined entry point.

When creating a managed image, 
the function specified with /ENTRY must have a signature of 
(LPVOID var1, DWORD var2, LPVOID var3).

For information on how to define your own DllMain entry point, 
see Run-Time Library Behavior .

To set this linker option in the Visual Studio development environment
Open the project's Property Pages dialog box. 
For details, see Setting Visual C++ Project Properties. 

Click the Linker folder.
Click the Advanced property page.
Modify the Entry Point property.

To set this linker option programmatically
See EntryPointSymbol.
See Also
///////////////////////////////////////////////////////////////////
 
  Copy Code 
/NOENTRY
 

Remarks
The /NOENTRY option is required for creating a resource-only DLL.

Use this option to prevent LINK from linking a reference 
to _main into the DLL.

To set this linker option in the Visual Studio development environment
Open the project's Property Pages dialog box. 
For details, see Setting Visual C++ Project Properties. 

Click the Linker folder.
Click the Advanced property page.
Modify the Resource Only DLL property.

To set this linker option programmatically
//////////////////////////////////////

LINK accepts COFF standard libraries and COFF import libraries, 
both of which usually have the extension .lib. 
Standard libraries contain objects and are created by the LIB tool. 
Import libraries contain information about exports in other programs 
and are created either by LINK when it builds a program 
that contains exports or by the LIB tool. 

For information on using LIB to create standard or import libraries, 
see LIB Reference. 

For details on using LINK to create an import library, 
see the /DLL option. 

A library is specified to LINK as either a file name argument or 
a default library. 
LINK resolves external references by searching first 
in libraries specified on the command line, 
then in default libraries specified with the /DEFAULTLIB option, 
and then in default libraries named in .obj files.
 
If a path is specified with the library name, 
LINK looks for the library in that directory. 

If no path is specified, 
LINK looks first in the directory that LINK is running from, 
and then in any directories specified 
	in the LIB environment variable.

To add .lib files as linker input in the development environment
Open the project's Property Pages dialog box. 
For details, see Setting Visual C++ Project Properties. 

Click the Linker folder.
Click the Input property page.
Modify the Additional Dependencies property.

To programmatically add .lib files as linker input
See AdditionalDependencies.
/////////////////////////////////////
Environment (Local Windows Debugger)
 Specifies environment variables for the program you are debugging. 
 These variables override the system environment or 
 are merged with the system environment, 
 depending on the Merge Environment setting. 
 When you click in the settings column, an ellipsis ( ) button appears. 
 Click on the ellipsis ( ) button to edit environment variables.
 ////////////////////////////////////////////////////
 






